import { db } from "@/app/lib/db";
import { NextResponse } from "next/server";
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({});

export async function POST(req: Request) {
    try {
        const { user_exam_id } = await req.json();

        // 1️⃣ Fetch the user exam along with exam → subjects → topics
        const userExam = await db.userExam.findUnique({
            where: { id: user_exam_id },
            include: {
                exam: {
                    include: {
                        subjects: { include: { topics: true } },
                    },
                },
            },
        });

        if (!userExam) throw new Error("UserExam not found");

        const { exam, start_date, end_date } = userExam;

        // 2️⃣ Build the structured subject/topic list for prompt
        const subjects = exam.subjects.map((s) => ({
            name: s.name,
            topics: s.topics.map((t) => t.name),
        }));

        // 3️⃣ Build AI Prompt
        const prompt = `
You are an expert academic planner. Create a study roadmap for the exam "${exam.name}" where description is a general brief discription of the roadmap and the summary is brief too but bit more specific summary of current roadmap on the basis of exam and duration provided.
The roadmap should help a student prepare effectively by breaking down the syllabus into manageable phases, weeks, and tasks.  Include milestones to track progress.
The preparation time is from ${start_date.toDateString()} to ${end_date.toDateString()} with subjetcs and topics are ${subjects.map((s) => `- ${s.name}: ${s.topics.join(", ")}`).join("\n")}.
Output ONLY a valid JSON structure in this exact format:
{
  "title": "string",
  "description": "string",
  "summary": "string",
  "phases": [
    {
      "phase_name": "string",
      "description": "string",
      "duration": "string",
      "start_date": "YYYY-MM-DD",
      "end_date": "YYYY-MM-DD",
      "weeks": [
        {
          "week_number": number,
          "start_date": "YYYY-MM-DD",
          "end_date": "YYYY-MM-DD",
          "focus": "string",
          "tasks": [
            {
              "title": "string",
              "description": "string",
              "start_date": "YYYY-MM-DD",
              "end_date": "YYYY-MM-DD"
            }
          ]
        }
      ]
    }
  ],
  "milestones": [
    { "name": "string", "goal": "string", "target_date": "YYYY-MM-DD" }
  ]
}`;

        // 4️⃣ Generate content from Gemini
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
        });

        let textResponse = response.text ?? "";

        // Clean possible code fences and formatting
        let cleanedText = textResponse
            .replace(/```json/i, "")
            .replace(/```/g, "")
            .trim()
            .replace(/,\s*}/g, "}")
            .replace(/,\s*]/g, "]");

        const roadmapData = JSON.parse(cleanedText);

        // 5️⃣ Create Roadmap (parent)
        const roadmap = await db.roadmap.create({
            data: {
                user_exam_id,
                title: roadmapData.title || `Roadmap for ${exam.name}`,
                description: roadmapData.description || "Generated by AI",
                summary: roadmapData.summary || null,
                generated_by_ai: true,
                start_date,
                end_date,
            },
        });

        // 6️⃣ Create hierarchical data: phases → weeks → tasks
        if (roadmapData.phases && Array.isArray(roadmapData.phases)) {
            for (const [phaseIndex, phase] of roadmapData.phases.entries()) {
                const createdPhase = await db.roadmapPhase.create({
                    data: {
                        roadmap_id: roadmap.id,
                        phase_name: phase.phase_name,
                        description: phase.description || null,
                        duration: phase.duration || null,
                        order_index: phaseIndex,
                    },
                });

                if (phase.weeks && Array.isArray(phase.weeks)) {
                    for (const [weekIndex, week] of phase.weeks.entries()) {
                        const createdWeek = await db.roadmapWeek.create({
                            data: {
                                phase_id: createdPhase.id,
                                week_number: week.week_number || weekIndex + 1,
                                focus: week.focus || null,
                                order_index: weekIndex,
                            },
                        });

                        if (week.tasks && Array.isArray(week.tasks)) {
                            await db.roadmapTask.createMany({
                                data: week.tasks.map((task: any, taskIndex: number) => ({
                                    week_id: createdWeek.id,
                                    title: task.title,
                                    description: task.description || null,
                                    start_date: task.start_date ? new Date(task.start_date) : null,
                                    end_date: task.end_date ? new Date(task.end_date) : null,
                                    order_index: taskIndex,
                                })),
                            });
                        }
                    }
                }
            }
        }

        // 7️⃣ Add milestones (if provided)
        if (roadmapData.milestones && Array.isArray(roadmapData.milestones)) {
            await db.milestone.createMany({
                data: roadmapData.milestones.map((m: any) => ({
                    roadmap_id: roadmap.id,
                    name: m.name,
                    goal: m.goal || null,
                    target_date: m.target_date ? new Date(m.target_date) : null,
                })),
            });
        }

        return NextResponse.json({
            success: true,
            roadmap_id: roadmap.id,
        });
    } catch (err: any) {
        console.error("❌ Roadmap generation failed:", err);
        return NextResponse.json(
            { error: err.message || "Something went wrong" },
            { status: 500 }
        );
    }
}
